{"ast":null,"code":"import axios from 'axios';\nexport const getCoingeckoMarketData = () => async dispatch => {\n  dispatch({\n    type: 'PRICE_LOADING'\n  });\n  axios.get('https://api.coingecko.com/api/v3/coins/statera', {\n    params: {\n      localization: 'false',\n      tickers: 'true',\n      market_data: 'true',\n      community_data: 'false',\n      developer_data: 'false',\n      sparkline: 'false'\n    }\n  }).then(_res => {\n    dispatch({\n      type: 'PRICE_SUCCESS',\n      payload: _res.data\n    });\n  }).catch(_error => {\n    dispatch({\n      type: 'PRICE_ERROR',\n      _error\n    });\n  });\n};","map":{"version":3,"sources":["/Users/nco/Documents/GitHub/dashboard/src/store/actions/statera.ts"],"names":["axios","getCoingeckoMarketData","dispatch","type","get","params","localization","tickers","market_data","community_data","developer_data","sparkline","then","_res","payload","data","catch","_error"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAGA,OAAO,MAAMC,sBAAsB,GAAG,MAAM,MAAOC,QAAP,IAA6B;AACvEA,EAAAA,QAAQ,CAAC;AAAEC,IAAAA,IAAI,EAAE;AAAR,GAAD,CAAR;AAEDH,EAAAA,KAAK,CAACI,GAAN,CAAU,gDAAV,EAA4D;AACzDC,IAAAA,MAAM,EAAE;AACNC,MAAAA,YAAY,EAAE,OADR;AAENC,MAAAA,OAAO,EAAE,MAFH;AAGNC,MAAAA,WAAW,EAAE,MAHP;AAINC,MAAAA,cAAc,EAAE,OAJV;AAKNC,MAAAA,cAAc,EAAE,OALV;AAMNC,MAAAA,SAAS,EAAE;AANL;AADiD,GAA5D,EAUIC,IAVJ,CAUSC,IAAI,IAAI;AACZX,IAAAA,QAAQ,CAAC;AAAEC,MAAAA,IAAI,EAAE,eAAR;AAAyBW,MAAAA,OAAO,EAAED,IAAI,CAACE;AAAvC,KAAD,CAAR;AACD,GAZJ,EAaIC,KAbJ,CAaUC,MAAM,IAAI;AACff,IAAAA,QAAQ,CAAC;AAAEC,MAAAA,IAAI,EAAE,aAAR;AAAuBc,MAAAA;AAAvB,KAAD,CAAR;AACD,GAfJ;AAgBA,CAnBM","sourcesContent":["import axios from 'axios'\r\nimport { Dispatch } from 'redux'\r\n\r\nexport const getCoingeckoMarketData = () => async (dispatch:Dispatch) => {\r\n  dispatch({ type: 'PRICE_LOADING' })\r\n\r\n\taxios.get('https://api.coingecko.com/api/v3/coins/statera', {\r\n    params: {\r\n      localization: 'false',\r\n      tickers: 'true',\r\n      market_data: 'true',\r\n      community_data: 'false',\r\n      developer_data: 'false',\r\n      sparkline: 'false',\r\n    }\r\n\t})\r\n    .then(_res => {\r\n      dispatch({ type: 'PRICE_SUCCESS', payload: _res.data })\r\n    })\r\n    .catch(_error => {\r\n      dispatch({ type: 'PRICE_ERROR', _error })\r\n    })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}