{"ast":null,"code":"import axios from 'axios';\nimport _ from 'lodash';\nimport log from '../../util/log';\nimport { DateTime } from 'luxon';\nimport Big from 'big.js';\nimport { resolvePoolFromContractAddress } from '../../util/resolvePool';\nexport const loadPool = () => async (dispatch, getState) => {\n  const contractAddress = getState().pool.contractAddress;\n  log.info('store:pool:load', contractAddress);\n  dispatch({\n    type: 'POOL_LOADING'\n  });\n  Promise.all([// getPrice(contractAddress),\n  // getStaSupply(contractAddress),\n  // getWStaSupply(contractAddress),\n  getChartData(contractAddress)]).then(_results => {\n    const anyErrors = _.some(_results, result => result.status === 'error');\n\n    log.info('store:statera:load:complete', _results, 'anyErrors?', anyErrors);\n\n    if (anyErrors) {\n      dispatch({\n        type: 'POOL_ERROR'\n      });\n    } else {\n      dispatch({\n        type: 'POOL_SUCCESS',\n        payload: _results\n      });\n    }\n  });\n}; // Chart\n\nconst getChartData = contractAddress => {\n  return new Promise(resolve => {\n    const from = DateTime.local().minus({\n      days: 365\n    }).toSeconds();\n    const to = DateTime.local().toSeconds();\n    const pool = resolvePoolFromContractAddress(contractAddress);\n    console.log('pool: ', pool);\n    console.log('assets', pool.assets[0].coinGeckoPathName, pool.assets[1].coinGeckoPathName);\n    Promise.all([axios.post('https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2', {\n      query: `\n          {\n            pairDayDatas (\n              where:{pairAddress: \"${pool.contractAddress}\"}\n              orderBy:date\n              orderDirection:desc\n              first:365\n            ) {\n              date\n              reserveUSD\n              dailyVolumeUSD\n              dailyVolumeToken0\n              dailyVolumeToken1\n              token0 {\n                id\n                symbol\n              }\n              token1 {\n                id\n                symbol\n              }\n            }\n          }\n        `\n    }), // As this store module is only ever for dual-asset pools, we can hardcode the index of the asset for these calls\n    axios.get(`https://api.coingecko.com/api/v3/coins/${pool.assets[0].coinGeckoPathName}/market_chart/range`, {\n      params: {\n        vs_currency: 'usd',\n        from,\n        to\n      }\n    }), axios.get(`https://api.coingecko.com/api/v3/coins/${pool.assets[1].coinGeckoPathName}/market_chart/range`, {\n      params: {\n        vs_currency: 'usd',\n        from,\n        to\n      }\n    })]).then(_res => {\n      log.info('pool:getChartData:success', _res);\n      const shortestDataLength = Math.min(...[_res[0].data.data.pairDayDatas.length, _res[1].data.prices.length, _res[2].data.prices.length]);\n      let graphData = _res[0].data.data.pairDayDatas;\n      graphData.reverse();\n\n      const coinGeckoPricesAsset0 = _res[1].data.prices.map(item => {\n        const dateAsString = item[0].toString();\n        return [Number(dateAsString.substring(0, dateAsString.length - 3)), item[1]];\n      });\n\n      const coinGeckoPricesAsset1 = _res[2].data.prices.map(item => {\n        const dateAsString = item[0].toString();\n        return [Number(dateAsString.substring(0, dateAsString.length - 3)), item[1]];\n      });\n\n      let volume = [];\n      let liquidity = [];\n      let feeReturns = [];\n\n      for (let index = 0; index < shortestDataLength; index++) {\n        const date = DateTime.fromObject({\n          hour: 0,\n          minute: 0,\n          second: 0\n        }).minus({\n          days: index\n        });\n        const targetDate = date.toSeconds();\n        const displayDate = date.toLocaleString(DateTime.DATE_MED);\n        const graphDataItem = graphData.find(item => item.date === targetDate);\n        const cgDataItem0 = coinGeckoPricesAsset0.find(item => item[0] === targetDate);\n        const assetPrice0 = cgDataItem0 ? cgDataItem0[1] : 0;\n        const cgDataItem1 = coinGeckoPricesAsset1.find(item => item[0] === targetDate);\n        const assetPrice1 = cgDataItem1 ? cgDataItem1[1] : 0;\n        const parsedLiquidity = (graphDataItem === null || graphDataItem === void 0 ? void 0 : graphDataItem.reserveUSD) ? Big(graphDataItem.reserveUSD).toNumber() : 0;\n        let assetVolume0 = 0;\n        let assetVolume1 = 0;\n\n        if (graphDataItem) {\n          if (graphDataItem.token0.id.toLowerCase() === pool.assets[0].contractAddress.toLowerCase()) {\n            assetVolume0 = Big(graphDataItem.dailyVolumeToken0).toNumber();\n            assetVolume1 = Big(graphDataItem.dailyVolumeToken1).toNumber();\n          } else if (graphDataItem.token1.id.toLowerCase() === pool.assets[0].contractAddress.toLowerCase()) {\n            assetVolume0 = Big(graphDataItem.dailyVolumeToken1).toNumber();\n            assetVolume1 = Big(graphDataItem.dailyVolumeToken0).toNumber();\n          }\n        }\n\n        const parsedVolume = assetPrice0 * assetVolume0 + assetPrice1 * assetVolume1;\n        const parsedFeeReturns = parsedVolume > 0 && parsedLiquidity > 0 ? Math.pow(parsedVolume * 0.003 / parsedLiquidity + 1, 365) - 1 : 0;\n        volume.push([displayDate, parsedVolume]);\n        liquidity.push([displayDate, parsedLiquidity]);\n        feeReturns.push([displayDate, parsedFeeReturns]);\n      }\n\n      volume.reverse();\n      liquidity.reverse();\n      feeReturns.reverse();\n\n      const day1ApyItems = _.takeRight(feeReturns, 1);\n\n      const day7ApyItems = _.takeRight(feeReturns, 7);\n\n      const day30ApyItems = _.takeRight(feeReturns, 30);\n\n      resolve({\n        name: 'chart',\n        status: 'success',\n        result: {\n          chart: {\n            volume,\n            liquidity,\n            feeReturns\n          },\n          apy: {\n            day1: day1ApyItems[0][1],\n            day7: _.meanBy(day7ApyItems, item => item[1]),\n            day30: _.meanBy(day30ApyItems, item => item[1])\n          }\n        }\n      });\n    }).catch(_error => {\n      resolve({\n        name: 'chart',\n        status: 'error',\n        result: _error\n      });\n    });\n  });\n};","map":{"version":3,"sources":["/Users/nco/Documents/GitHub/dashboard/src/store/actions/pool.ts"],"names":["axios","_","log","DateTime","Big","resolvePoolFromContractAddress","loadPool","dispatch","getState","contractAddress","pool","info","type","Promise","all","getChartData","then","_results","anyErrors","some","result","status","payload","resolve","from","local","minus","days","toSeconds","to","console","assets","coinGeckoPathName","post","query","get","params","vs_currency","_res","shortestDataLength","Math","min","data","pairDayDatas","length","prices","graphData","reverse","coinGeckoPricesAsset0","map","item","dateAsString","toString","Number","substring","coinGeckoPricesAsset1","volume","liquidity","feeReturns","index","date","fromObject","hour","minute","second","targetDate","displayDate","toLocaleString","DATE_MED","graphDataItem","find","cgDataItem0","assetPrice0","cgDataItem1","assetPrice1","parsedLiquidity","reserveUSD","toNumber","assetVolume0","assetVolume1","token0","id","toLowerCase","dailyVolumeToken0","dailyVolumeToken1","token1","parsedVolume","parsedFeeReturns","pow","push","day1ApyItems","takeRight","day7ApyItems","day30ApyItems","name","chart","apy","day1","day7","meanBy","day30","catch","_error"],"mappings":"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","sourcesContent":["import axios from 'axios'\r\nimport { Dispatch } from 'redux'\r\nimport _ from 'lodash'\r\nimport log from '../../util/log'\r\nimport { DateTime } from 'luxon'\r\nimport Big from 'big.js'\r\nimport { resolvePoolFromContractAddress } from '../../util/resolvePool'\r\n\r\nexport const loadPool = () => async (dispatch:Dispatch, getState:any) => {\r\n  const contractAddress:string = getState().pool.contractAddress\r\n  log.info('store:pool:load', contractAddress)\r\n  dispatch({ type: 'POOL_LOADING' })\r\n\r\n  Promise.all([\r\n    // getPrice(contractAddress),\r\n    // getStaSupply(contractAddress),\r\n    // getWStaSupply(contractAddress),\r\n    getChartData(contractAddress),\r\n  ])\r\n    .then(_results => {\r\n      const anyErrors = _.some(_results, (result:any) => result.status === 'error')\r\n      log.info('store:statera:load:complete', _results, 'anyErrors?', anyErrors)\r\n\r\n      if (anyErrors) {\r\n        dispatch({ type: 'POOL_ERROR' })\r\n      } else {\r\n        dispatch({ type: 'POOL_SUCCESS', payload: _results })\r\n      }\r\n    })\r\n}\r\n\r\n\r\n// Chart\r\n\r\nconst getChartData = (contractAddress:string) => {\r\n  return new Promise(resolve => {\r\n    const from = DateTime.local().minus({ days: 365 }).toSeconds()\r\n    const to = DateTime.local().toSeconds()\r\n    const pool:any = resolvePoolFromContractAddress(contractAddress)\r\n    console.log('pool: ', pool);\r\n\r\n    console.log('assets', pool.assets[0].coinGeckoPathName, pool.assets[1].coinGeckoPathName)\r\n\r\n    Promise.all([\r\n      axios.post('https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2', {\r\n        query: `\r\n          {\r\n            pairDayDatas (\r\n              where:{pairAddress: \"${pool.contractAddress}\"}\r\n              orderBy:date\r\n              orderDirection:desc\r\n              first:365\r\n            ) {\r\n              date\r\n              reserveUSD\r\n              dailyVolumeUSD\r\n              dailyVolumeToken0\r\n              dailyVolumeToken1\r\n              token0 {\r\n                id\r\n                symbol\r\n              }\r\n              token1 {\r\n                id\r\n                symbol\r\n              }\r\n            }\r\n          }\r\n        `\r\n      }),\r\n      // As this store module is only ever for dual-asset pools, we can hardcode the index of the asset for these calls\r\n      axios.get(`https://api.coingecko.com/api/v3/coins/${pool.assets[0].coinGeckoPathName}/market_chart/range`, {\r\n        params: {\r\n          vs_currency: 'usd',\r\n          from,\r\n          to,\r\n        },\r\n      }),\r\n      axios.get(`https://api.coingecko.com/api/v3/coins/${pool.assets[1].coinGeckoPathName}/market_chart/range`, {\r\n        params: {\r\n          vs_currency: 'usd',\r\n          from,\r\n          to,\r\n        },\r\n      }),\r\n    ])\r\n      .then(_res => {\r\n        log.info('pool:getChartData:success', _res)\r\n\r\n        const shortestDataLength = Math.min(...[\r\n          _res[0].data.data.pairDayDatas.length,\r\n          _res[1].data.prices.length,\r\n          _res[2].data.prices.length,\r\n        ])\r\n\r\n        let graphData = _res[0].data.data.pairDayDatas\r\n        graphData.reverse()\r\n\r\n        const coinGeckoPricesAsset0 = _res[1].data.prices.map((item:any) => {\r\n          const dateAsString = item[0].toString()\r\n          return [\r\n            Number(dateAsString.substring(0, dateAsString.length - 3)),\r\n            item[1]\r\n          ]\r\n        })\r\n\r\n        const coinGeckoPricesAsset1 = _res[2].data.prices.map((item:any) => {\r\n          const dateAsString = item[0].toString()\r\n          return [\r\n            Number(dateAsString.substring(0, dateAsString.length - 3)),\r\n            item[1]\r\n          ]\r\n        })\r\n\r\n        let volume:any = []\r\n        let liquidity:any = []\r\n        let feeReturns:any = []\r\n\r\n        for (let index = 0; index < shortestDataLength; index++) {\r\n          const date = DateTime.fromObject({ hour: 0, minute: 0, second: 0 }).minus({ days: index })\r\n          const targetDate = date.toSeconds()\r\n          const displayDate = date.toLocaleString(DateTime.DATE_MED)\r\n\r\n          const graphDataItem = graphData.find((item:any) => item.date === targetDate)\r\n          const cgDataItem0 = coinGeckoPricesAsset0.find((item:any) => item[0] === targetDate)\r\n          const assetPrice0 = cgDataItem0 ? cgDataItem0[1] : 0\r\n\r\n          const cgDataItem1 = coinGeckoPricesAsset1.find((item:any) => item[0] === targetDate)\r\n          const assetPrice1 = cgDataItem1 ? cgDataItem1[1] : 0\r\n\r\n          const parsedLiquidity = graphDataItem?.reserveUSD ? Big(graphDataItem.reserveUSD).toNumber() : 0\r\n\r\n          let assetVolume0 = 0\r\n          let assetVolume1 = 0\r\n          if (graphDataItem) {\r\n            if (graphDataItem.token0.id.toLowerCase() === pool.assets[0].contractAddress.toLowerCase()) {\r\n              assetVolume0 = Big(graphDataItem.dailyVolumeToken0).toNumber()\r\n              assetVolume1 = Big(graphDataItem.dailyVolumeToken1).toNumber()\r\n            } else if (graphDataItem.token1.id.toLowerCase() === pool.assets[0].contractAddress.toLowerCase()) {\r\n              assetVolume0 = Big(graphDataItem.dailyVolumeToken1).toNumber()\r\n              assetVolume1 = Big(graphDataItem.dailyVolumeToken0).toNumber()\r\n            }\r\n          }\r\n\r\n          const parsedVolume = (assetPrice0 * assetVolume0) + (assetPrice1 * assetVolume1)\r\n          const parsedFeeReturns = (parsedVolume > 0 && parsedLiquidity > 0) ? (Math.pow((((parsedVolume * 0.003) / parsedLiquidity) + 1), 365)) -1 : 0\r\n\r\n          volume.push([\r\n            displayDate,\r\n            parsedVolume,\r\n          ])\r\n\r\n          liquidity.push([\r\n            displayDate,\r\n            parsedLiquidity,\r\n          ])\r\n\r\n          feeReturns.push([\r\n            displayDate,\r\n            parsedFeeReturns,\r\n          ])\r\n        }\r\n\r\n        volume.reverse()\r\n        liquidity.reverse()\r\n        feeReturns.reverse()\r\n\r\n        const day1ApyItems:any = _.takeRight(feeReturns, 1)\r\n        const day7ApyItems:any = _.takeRight(feeReturns, 7)\r\n        const day30ApyItems:any = _.takeRight(feeReturns, 30)\r\n\r\n        resolve({\r\n          name: 'chart',\r\n          status: 'success',\r\n          result: {\r\n            chart: {\r\n              volume,\r\n              liquidity,\r\n              feeReturns,\r\n            },\r\n            apy: {\r\n              day1: day1ApyItems[0][1],\r\n              day7: _.meanBy(day7ApyItems, (item:any) => item[1]),\r\n              day30: _.meanBy(day30ApyItems, (item:any) => item[1]),\r\n            },\r\n          },\r\n        })\r\n      })\r\n      .catch(_error => {\r\n        resolve({\r\n          name: 'chart',\r\n          status: 'error',\r\n          result: _error\r\n        })\r\n      })\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}