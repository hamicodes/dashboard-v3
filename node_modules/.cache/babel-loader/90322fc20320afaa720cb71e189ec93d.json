{"ast":null,"code":"import { useContext, useEffect } from 'react';\nimport useSWR, { cache, mutate } from 'swr';\nimport { isAddress } from '@ethersproject/address';\nimport EthSWRConfigContext from './eth-swr-config';\nimport { etherJsFetcher } from './ether-js-fetcher';\nimport { ABINotFound } from './Errors';\nimport { getContract, contracts } from './utils';\nexport { cache } from 'swr';\n\nfunction useEtherSWR(...args) {\n  let _key;\n\n  let _keys;\n\n  let fn; //fetcherFn<Data> | undefined\n\n  let config = {\n    subscribe: []\n  };\n  let isMulticall = false;\n\n  if (args.length >= 1) {\n    _key = args[0];\n    isMulticall = Array.isArray(_key[0]);\n  }\n\n  if (args.length > 2) {\n    fn = args[1]; //FIXME we lost default value subscriber = []\n\n    config = args[2];\n  } else {\n    if (typeof args[1] === 'function') {\n      fn = args[1];\n    } else if (typeof args[1] === 'object') {\n      config = args[1];\n    }\n  }\n\n  config = Object.assign({}, useContext(EthSWRConfigContext), config);\n\n  if (fn === undefined) {\n    // fn = config.fetcher(library, config.ABIs) as any\n    fn = config.fetcher || etherJsFetcher(config.provider, config.ABIs);\n  } // TODO LS implement a getTarget and change subscribe interface {subscribe: {name: \"Transfer\", target: 0x01}}\n\n\n  const [target] = isMulticall ? [_key[0][0]] // pick the first element of the list.\n  : _key; // we need to serialize the key as string otherwise\n  // a new array is created everytime the component is rendered\n  // we follow SWR format\n\n  const serializedKey = isMulticall ? JSON.stringify(_key) : cache.serializeKey(_key)[0]; // const joinKey = `arg@\"${_key.join('\"@\"')}\"`\n  // const joinKey = `arg@\"${JSON.stringify(_key)}\"`\n  // base methods (e.g. getBalance, getBlockNumber, etc)\n  // FIXME merge in only one useEffect\n\n  useEffect(() => {\n    if (!config.provider || !config.subscribe || isAddress(target) || Array.isArray(target)) {\n      return () => ({});\n    }\n\n    const subscribers = Array.isArray(config.subscribe) ? config.subscribe : [config.subscribe];\n    subscribers.forEach(subscribe => {\n      let filter; // const joinKey = isMulticall ? serializedKey : cache.serializeKey(_key)[0]\n\n      const joinKey = serializedKey;\n\n      if (typeof subscribe === 'string') {\n        filter = subscribe; // TODO LS this depends on etherjs\n\n        config.provider.on(filter, () => {\n          // console.log('on:', { filter }, cache.keys())\n          mutate(joinKey, undefined, true);\n        });\n      } else if (typeof subscribe === 'object' && !Array.isArray(subscribe)) {\n        const {\n          name,\n          on\n        } = subscribe;\n        filter = name;\n        config.provider.on(filter, (...args) => {\n          if (on) {\n            on(cache.get(joinKey), ...args);\n          } else {\n            // auto refresh\n            mutate(joinKey, undefined, true);\n          }\n        });\n      }\n    });\n    return () => {\n      subscribers.forEach(filter => {\n        config.provider.removeAllListeners(filter);\n      });\n    };\n  }, [serializedKey, target]); // contract filter (e.g. balanceOf, approve, etc)\n  // FIXME merge in only one useEffect\n\n  useEffect(() => {\n    if (!config.provider || !config.subscribe || !isAddress(target)) {\n      return () => ({});\n    }\n\n    const abi = config.ABIs.get(target); // console.log('useEffect configure', _key)\n\n    if (!abi) {\n      throw new ABINotFound(`Missing ABI for ${target}`);\n    } // const contract = new Contract(target, abi, config.provider.getSigner())\n\n\n    const contract = getContract(target, abi, config.provider.getSigner());\n    const subscribers = Array.isArray(config.subscribe) ? config.subscribe : [config.subscribe];\n    subscribers.forEach(subscribe => {\n      let filter; // const joinKey = isMulticall ? cache.serializeKey(serializedKey)[0] : _key\n\n      if (typeof subscribe === 'string') {\n        filter = contract.filters[subscribe](); // console.log('set:', { filter }, cache.keys())\n\n        contract.on(filter, value => {\n          // auto refresh\n          // console.log('on:', { filter }, cache.keys())\n          mutate(serializedKey, undefined, true);\n        });\n      } else if (typeof subscribe === 'object' && !Array.isArray(subscribe)) {\n        const {\n          name,\n          topics,\n          on\n        } = subscribe;\n        const args = topics || [];\n        filter = contract.filters[name](...args); // console.log('subscribe:', filter)\n\n        contract.on(filter, (...args) => {\n          // console.log(`on_${name}:`, args)\n          if (on) {\n            on(cache.get(serializedKey), ...args);\n          } else {\n            // auto refresh\n            mutate(_key, undefined, true);\n          }\n        });\n      }\n    });\n    return () => {\n      // console.log('== unmount  ==', target)\n      // console.log('size', contracts.size)\n      subscribers.forEach(filter => {\n        // FIXME the filter need to be unwrap to find the listener as for above\n        contract.removeAllListeners(filter);\n      });\n      contracts.delete(target);\n    }; // FIXME revalidate if network change\n  }, [serializedKey, target]); // FIXME serialize as string if the key is an array aka multicall\n\n  return useSWR(isMulticall ? serializedKey : _key, fn, config);\n}\n\nconst EthSWRConfig = EthSWRConfigContext.Provider;\nexport { EthSWRConfig };\nexport default useEtherSWR;","map":{"version":3,"sources":["/Users/nco/Documents/GitHub/dashboard/node_modules/ether-swr/esm/useEtherSWR.js"],"names":["useContext","useEffect","useSWR","cache","mutate","isAddress","EthSWRConfigContext","etherJsFetcher","ABINotFound","getContract","contracts","useEtherSWR","args","_key","_keys","fn","config","subscribe","isMulticall","length","Array","isArray","Object","assign","undefined","fetcher","provider","ABIs","target","serializedKey","JSON","stringify","serializeKey","subscribers","forEach","filter","joinKey","on","name","get","removeAllListeners","abi","contract","getSigner","filters","value","topics","delete","EthSWRConfig","Provider"],"mappings":"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","sourcesContent":["import { useContext, useEffect } from 'react';\nimport useSWR, { cache, mutate } from 'swr';\nimport { isAddress } from '@ethersproject/address';\nimport EthSWRConfigContext from './eth-swr-config';\nimport { etherJsFetcher } from './ether-js-fetcher';\nimport { ABINotFound } from './Errors';\nimport { getContract, contracts } from './utils';\nexport { cache } from 'swr';\nfunction useEtherSWR(...args) {\n    let _key;\n    let _keys;\n    let fn; //fetcherFn<Data> | undefined\n    let config = { subscribe: [] };\n    let isMulticall = false;\n    if (args.length >= 1) {\n        _key = args[0];\n        isMulticall = Array.isArray(_key[0]);\n    }\n    if (args.length > 2) {\n        fn = args[1];\n        //FIXME we lost default value subscriber = []\n        config = args[2];\n    }\n    else {\n        if (typeof args[1] === 'function') {\n            fn = args[1];\n        }\n        else if (typeof args[1] === 'object') {\n            config = args[1];\n        }\n    }\n    config = Object.assign({}, useContext(EthSWRConfigContext), config);\n    if (fn === undefined) {\n        // fn = config.fetcher(library, config.ABIs) as any\n        fn = config.fetcher || etherJsFetcher(config.provider, config.ABIs);\n    }\n    // TODO LS implement a getTarget and change subscribe interface {subscribe: {name: \"Transfer\", target: 0x01}}\n    const [target] = isMulticall\n        ? [_key[0][0]] // pick the first element of the list.\n        : _key;\n    // we need to serialize the key as string otherwise\n    // a new array is created everytime the component is rendered\n    // we follow SWR format\n    const serializedKey = isMulticall\n        ? JSON.stringify(_key)\n        : cache.serializeKey(_key)[0];\n    // const joinKey = `arg@\"${_key.join('\"@\"')}\"`\n    // const joinKey = `arg@\"${JSON.stringify(_key)}\"`\n    // base methods (e.g. getBalance, getBlockNumber, etc)\n    // FIXME merge in only one useEffect\n    useEffect(() => {\n        if (!config.provider ||\n            !config.subscribe ||\n            isAddress(target) ||\n            Array.isArray(target)) {\n            return () => ({});\n        }\n        const subscribers = Array.isArray(config.subscribe)\n            ? config.subscribe\n            : [config.subscribe];\n        subscribers.forEach(subscribe => {\n            let filter;\n            // const joinKey = isMulticall ? serializedKey : cache.serializeKey(_key)[0]\n            const joinKey = serializedKey;\n            if (typeof subscribe === 'string') {\n                filter = subscribe;\n                // TODO LS this depends on etherjs\n                config.provider.on(filter, () => {\n                    // console.log('on:', { filter }, cache.keys())\n                    mutate(joinKey, undefined, true);\n                });\n            }\n            else if (typeof subscribe === 'object' && !Array.isArray(subscribe)) {\n                const { name, on } = subscribe;\n                filter = name;\n                config.provider.on(filter, (...args) => {\n                    if (on) {\n                        on(cache.get(joinKey), ...args);\n                    }\n                    else {\n                        // auto refresh\n                        mutate(joinKey, undefined, true);\n                    }\n                });\n            }\n        });\n        return () => {\n            subscribers.forEach(filter => {\n                config.provider.removeAllListeners(filter);\n            });\n        };\n    }, [serializedKey, target]);\n    // contract filter (e.g. balanceOf, approve, etc)\n    // FIXME merge in only one useEffect\n    useEffect(() => {\n        if (!config.provider || !config.subscribe || !isAddress(target)) {\n            return () => ({});\n        }\n        const abi = config.ABIs.get(target);\n        // console.log('useEffect configure', _key)\n        if (!abi) {\n            throw new ABINotFound(`Missing ABI for ${target}`);\n        }\n        // const contract = new Contract(target, abi, config.provider.getSigner())\n        const contract = getContract(target, abi, config.provider.getSigner());\n        const subscribers = Array.isArray(config.subscribe)\n            ? config.subscribe\n            : [config.subscribe];\n        subscribers.forEach(subscribe => {\n            let filter;\n            // const joinKey = isMulticall ? cache.serializeKey(serializedKey)[0] : _key\n            if (typeof subscribe === 'string') {\n                filter = contract.filters[subscribe]();\n                // console.log('set:', { filter }, cache.keys())\n                contract.on(filter, value => {\n                    // auto refresh\n                    // console.log('on:', { filter }, cache.keys())\n                    mutate(serializedKey, undefined, true);\n                });\n            }\n            else if (typeof subscribe === 'object' && !Array.isArray(subscribe)) {\n                const { name, topics, on } = subscribe;\n                const args = topics || [];\n                filter = contract.filters[name](...args);\n                // console.log('subscribe:', filter)\n                contract.on(filter, (...args) => {\n                    // console.log(`on_${name}:`, args)\n                    if (on) {\n                        on(cache.get(serializedKey), ...args);\n                    }\n                    else {\n                        // auto refresh\n                        mutate(_key, undefined, true);\n                    }\n                });\n            }\n        });\n        return () => {\n            // console.log('== unmount  ==', target)\n            // console.log('size', contracts.size)\n            subscribers.forEach(filter => {\n                // FIXME the filter need to be unwrap to find the listener as for above\n                contract.removeAllListeners(filter);\n            });\n            contracts.delete(target);\n        };\n        // FIXME revalidate if network change\n    }, [serializedKey, target]);\n    // FIXME serialize as string if the key is an array aka multicall\n    return useSWR(isMulticall ? serializedKey : _key, fn, config);\n}\nconst EthSWRConfig = EthSWRConfigContext.Provider;\nexport { EthSWRConfig };\nexport default useEtherSWR;\n"]},"metadata":{},"sourceType":"module"}